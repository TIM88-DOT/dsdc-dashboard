{"ast":null,"code":"// src/index.ts\nimport JSBI2 from \"jsbi\";\n\n// src/constants.ts\nimport { Percent } from \"@pancakeswap/swap-sdk-core\";\n\n// src/entities/token.ts\nimport { Token } from \"@pancakeswap/swap-sdk-core\";\n\n// src/utils.ts\nimport { getAddress } from \"@ethersproject/address\";\nimport invariant from \"tiny-invariant\";\nimport warning from \"tiny-warning\";\nfunction validateAndParseAddress(address) {\n  try {\n    const checksummedAddress = getAddress(address);\n    warning(address === checksummedAddress, `${address} is not checksummed.`);\n    return checksummedAddress;\n  } catch (error) {\n    invariant(false, `${address} is not a valid address.`);\n  }\n}\n\n// src/entities/token.ts\nvar ERC20Token = class extends Token {\n  constructor(chainId, address, decimals, symbol, name, projectLink) {\n    super(chainId, validateAndParseAddress(address), decimals, symbol, name, projectLink);\n  }\n};\n\n// src/constants.ts\nvar ChainId = /* @__PURE__ */(ChainId2 => {\n  ChainId2[ChainId2[\"ETHEREUM\"] = 1] = \"ETHEREUM\";\n  ChainId2[ChainId2[\"GOERLI\"] = 5] = \"GOERLI\";\n  ChainId2[ChainId2[\"BSC\"] = 56] = \"BSC\";\n  ChainId2[ChainId2[\"BSC_TESTNET\"] = 97] = \"BSC_TESTNET\";\n  return ChainId2;\n})(ChainId || {});\nvar ZERO_PERCENT = new Percent(\"0\");\nvar ONE_HUNDRED_PERCENT = new Percent(\"1\");\nvar FACTORY_ADDRESS = \"0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73\";\nvar FACTORY_ADDRESS_ETH = \"0x1097053Fd2ea711dad45caCcc45EfF7548fCB362\";\nvar FACTORY_ADDRESS_MAP = {\n  [1 /* ETHEREUM */]: FACTORY_ADDRESS_ETH,\n  [5 /* GOERLI */]: FACTORY_ADDRESS_ETH,\n  [56 /* BSC */]: FACTORY_ADDRESS,\n  [97 /* BSC_TESTNET */]: \"0x6725f303b657a9451d8ba641348b6761a6cc7a17\"\n};\nvar INIT_CODE_HASH = \"0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5\";\nvar INIT_CODE_HASH_ETH = \"0x57224589c67f3f30a6b0d7a1b54cf3153ab84563bc609ef41dfb34f8b2974d2d\";\nvar INIT_CODE_HASH_MAP = {\n  [1 /* ETHEREUM */]: INIT_CODE_HASH_ETH,\n  [5 /* GOERLI */]: INIT_CODE_HASH_ETH,\n  [56 /* BSC */]: INIT_CODE_HASH,\n  [97 /* BSC_TESTNET */]: \"0xd0d4c4cd0848c93cb4fd1f498d7013ee6bfb25783ea21593d5834f5d250ece66\"\n};\nvar WETH9 = {\n  [1 /* ETHEREUM */]: new ERC20Token(1 /* ETHEREUM */, \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\", 18, \"WETH\", \"Wrapped Ether\", \"https://weth.io\"),\n  [5 /* GOERLI */]: new ERC20Token(5 /* GOERLI */, \"0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6\", 18, \"WETH\", \"Wrapped Ether\", \"https://weth.io\")\n};\nvar WBNB = {\n  [1 /* ETHEREUM */]: new ERC20Token(1 /* ETHEREUM */, \"0x418D75f65a02b3D53B2418FB8E1fe493759c7605\", 18, \"WBNB\", \"Wrapped BNB\", \"https://www.binance.org\"),\n  [56 /* BSC */]: new ERC20Token(56 /* BSC */, \"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\", 18, \"WBNB\", \"Wrapped BNB\", \"https://www.binance.org\"),\n  [97 /* BSC_TESTNET */]: new ERC20Token(97 /* BSC_TESTNET */, \"0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd\", 18, \"WBNB\", \"Wrapped BNB\", \"https://www.binance.org\")\n};\nvar WNATIVE = {\n  [1 /* ETHEREUM */]: WETH9[1 /* ETHEREUM */],\n  [5 /* GOERLI */]: WETH9[5 /* GOERLI */],\n  [56 /* BSC */]: WBNB[56 /* BSC */],\n  [97 /* BSC_TESTNET */]: WBNB[97 /* BSC_TESTNET */]\n};\n\nvar NATIVE = {\n  [1 /* ETHEREUM */]: {\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18\n  },\n  [5 /* GOERLI */]: {\n    name: \"Goerli Ether\",\n    symbol: \"GOR\",\n    decimals: 18\n  },\n  [56 /* BSC */]: {\n    name: \"Binance Chain Native Token\",\n    symbol: \"BNB\",\n    decimals: 18\n  },\n  [97 /* BSC_TESTNET */]: {\n    name: \"Binance Chain Native Token\",\n    symbol: \"tBNB\",\n    decimals: 18\n  }\n};\n\n// src/trade.ts\nfunction isTradeBetter(tradeA, tradeB) {\n  let minimumDelta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ZERO_PERCENT;\n  if (tradeA && !tradeB) return false;\n  if (tradeB && !tradeA) return true;\n  if (!tradeA || !tradeB) return void 0;\n  if (tradeA.tradeType !== tradeB.tradeType || !tradeA.inputAmount.currency.equals(tradeB.inputAmount.currency) || !tradeA.outputAmount.currency.equals(tradeB.outputAmount.currency)) {\n    throw new Error(\"Trades are not comparable\");\n  }\n  if (minimumDelta.equalTo(ZERO_PERCENT)) {\n    return tradeA.executionPrice.lessThan(tradeB.executionPrice);\n  }\n  return tradeA.executionPrice.asFraction.multiply(minimumDelta.add(ONE_HUNDRED_PERCENT)).lessThan(tradeB.executionPrice);\n}\n\n// src/entities/pair.ts\nimport { InsufficientInputAmountError, InsufficientReservesError, sqrt, CurrencyAmount, Price, FIVE, ONE, ZERO, _10000, _9975, MINIMUM_LIQUIDITY } from \"@pancakeswap/swap-sdk-core\";\nimport { getCreate2Address } from \"@ethersproject/address\";\nimport { keccak256, pack } from \"@ethersproject/solidity\";\nimport JSBI from \"jsbi\";\nimport invariant2 from \"tiny-invariant\";\nvar PAIR_ADDRESS_CACHE = {};\nvar composeKey = (token0, token1) => `${token0.chainId}-${token0.address}-${token1.address}`;\nvar computePairAddress = _ref => {\n  let {\n    factoryAddress,\n    tokenA,\n    tokenB\n  } = _ref;\n  const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];\n  const key = composeKey(token0, token1);\n  if ((PAIR_ADDRESS_CACHE == null ? void 0 : PAIR_ADDRESS_CACHE[key]) === void 0) {\n    PAIR_ADDRESS_CACHE = {\n      ...PAIR_ADDRESS_CACHE,\n      [key]: getCreate2Address(factoryAddress, keccak256([\"bytes\"], [pack([\"address\", \"address\"], [token0.address, token1.address])]), INIT_CODE_HASH_MAP[token0.chainId])\n    };\n  }\n  return PAIR_ADDRESS_CACHE[key];\n};\nvar Pair = class {\n  static getAddress(tokenA, tokenB) {\n    return computePairAddress({\n      factoryAddress: FACTORY_ADDRESS_MAP[tokenA.chainId],\n      tokenA,\n      tokenB\n    });\n  }\n  constructor(currencyAmountA, tokenAmountB) {\n    const tokenAmounts = currencyAmountA.currency.sortsBefore(tokenAmountB.currency) ? [currencyAmountA, tokenAmountB] : [tokenAmountB, currencyAmountA];\n    this.liquidityToken = new ERC20Token(tokenAmounts[0].currency.chainId, Pair.getAddress(tokenAmounts[0].currency, tokenAmounts[1].currency), 18, \"Cake-LP\", \"Pancake LPs\");\n    this.tokenAmounts = tokenAmounts;\n  }\n  involvesToken(token) {\n    return token.equals(this.token0) || token.equals(this.token1);\n  }\n  get token0Price() {\n    const result = this.tokenAmounts[1].divide(this.tokenAmounts[0]);\n    return new Price(this.token0, this.token1, result.denominator, result.numerator);\n  }\n  get token1Price() {\n    const result = this.tokenAmounts[0].divide(this.tokenAmounts[1]);\n    return new Price(this.token1, this.token0, result.denominator, result.numerator);\n  }\n  priceOf(token) {\n    invariant2(this.involvesToken(token), \"TOKEN\");\n    return token.equals(this.token0) ? this.token0Price : this.token1Price;\n  }\n  get chainId() {\n    return this.token0.chainId;\n  }\n  get token0() {\n    return this.tokenAmounts[0].currency;\n  }\n  get token1() {\n    return this.tokenAmounts[1].currency;\n  }\n  get reserve0() {\n    return this.tokenAmounts[0];\n  }\n  get reserve1() {\n    return this.tokenAmounts[1];\n  }\n  reserveOf(token) {\n    invariant2(this.involvesToken(token), \"TOKEN\");\n    return token.equals(this.token0) ? this.reserve0 : this.reserve1;\n  }\n  getOutputAmount(inputAmount) {\n    invariant2(this.involvesToken(inputAmount.currency), \"TOKEN\");\n    if (JSBI.equal(this.reserve0.quotient, ZERO) || JSBI.equal(this.reserve1.quotient, ZERO)) {\n      throw new InsufficientReservesError();\n    }\n    const inputReserve = this.reserveOf(inputAmount.currency);\n    const outputReserve = this.reserveOf(inputAmount.currency.equals(this.token0) ? this.token1 : this.token0);\n    const inputAmountWithFee = JSBI.multiply(inputAmount.quotient, _9975);\n    const numerator = JSBI.multiply(inputAmountWithFee, outputReserve.quotient);\n    const denominator = JSBI.add(JSBI.multiply(inputReserve.quotient, _10000), inputAmountWithFee);\n    const outputAmount = CurrencyAmount.fromRawAmount(inputAmount.currency.equals(this.token0) ? this.token1 : this.token0, JSBI.divide(numerator, denominator));\n    if (JSBI.equal(outputAmount.quotient, ZERO)) {\n      throw new InsufficientInputAmountError();\n    }\n    return [outputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))];\n  }\n  getInputAmount(outputAmount) {\n    invariant2(this.involvesToken(outputAmount.currency), \"TOKEN\");\n    if (JSBI.equal(this.reserve0.quotient, ZERO) || JSBI.equal(this.reserve1.quotient, ZERO) || JSBI.greaterThanOrEqual(outputAmount.quotient, this.reserveOf(outputAmount.currency).quotient)) {\n      throw new InsufficientReservesError();\n    }\n    const outputReserve = this.reserveOf(outputAmount.currency);\n    const inputReserve = this.reserveOf(outputAmount.currency.equals(this.token0) ? this.token1 : this.token0);\n    const numerator = JSBI.multiply(JSBI.multiply(inputReserve.quotient, outputAmount.quotient), _10000);\n    const denominator = JSBI.multiply(JSBI.subtract(outputReserve.quotient, outputAmount.quotient), _9975);\n    const inputAmount = CurrencyAmount.fromRawAmount(outputAmount.currency.equals(this.token0) ? this.token1 : this.token0, JSBI.add(JSBI.divide(numerator, denominator), ONE));\n    return [inputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))];\n  }\n  getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB) {\n    invariant2(totalSupply.currency.equals(this.liquidityToken), \"LIQUIDITY\");\n    const tokenAmounts = tokenAmountA.currency.sortsBefore(tokenAmountB.currency) ? [tokenAmountA, tokenAmountB] : [tokenAmountB, tokenAmountA];\n    invariant2(tokenAmounts[0].currency.equals(this.token0) && tokenAmounts[1].currency.equals(this.token1), \"TOKEN\");\n    let liquidity;\n    if (JSBI.equal(totalSupply.quotient, ZERO)) {\n      liquidity = JSBI.subtract(sqrt(JSBI.multiply(tokenAmounts[0].quotient, tokenAmounts[1].quotient)), MINIMUM_LIQUIDITY);\n    } else {\n      const amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].quotient, totalSupply.quotient), this.reserve0.quotient);\n      const amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].quotient, totalSupply.quotient), this.reserve1.quotient);\n      liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1;\n    }\n    if (!JSBI.greaterThan(liquidity, ZERO)) {\n      throw new InsufficientInputAmountError();\n    }\n    return CurrencyAmount.fromRawAmount(this.liquidityToken, liquidity);\n  }\n  getLiquidityValue(token, totalSupply, liquidity) {\n    let feeOn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let kLast = arguments.length > 4 ? arguments[4] : undefined;\n    invariant2(this.involvesToken(token), \"TOKEN\");\n    invariant2(totalSupply.currency.equals(this.liquidityToken), \"TOTAL_SUPPLY\");\n    invariant2(liquidity.currency.equals(this.liquidityToken), \"LIQUIDITY\");\n    invariant2(JSBI.lessThanOrEqual(liquidity.quotient, totalSupply.quotient), \"LIQUIDITY\");\n    let totalSupplyAdjusted;\n    if (!feeOn) {\n      totalSupplyAdjusted = totalSupply;\n    } else {\n      invariant2(!!kLast, \"K_LAST\");\n      const kLastParsed = JSBI.BigInt(kLast);\n      if (!JSBI.equal(kLastParsed, ZERO)) {\n        const rootK = sqrt(JSBI.multiply(this.reserve0.quotient, this.reserve1.quotient));\n        const rootKLast = sqrt(kLastParsed);\n        if (JSBI.greaterThan(rootK, rootKLast)) {\n          const numerator = JSBI.multiply(totalSupply.quotient, JSBI.subtract(rootK, rootKLast));\n          const denominator = JSBI.add(JSBI.multiply(rootK, FIVE), rootKLast);\n          const feeLiquidity = JSBI.divide(numerator, denominator);\n          totalSupplyAdjusted = totalSupply.add(CurrencyAmount.fromRawAmount(this.liquidityToken, feeLiquidity));\n        } else {\n          totalSupplyAdjusted = totalSupply;\n        }\n      } else {\n        totalSupplyAdjusted = totalSupply;\n      }\n    }\n    return CurrencyAmount.fromRawAmount(token, JSBI.divide(JSBI.multiply(liquidity.quotient, this.reserveOf(token).quotient), totalSupplyAdjusted.quotient));\n  }\n};\n\n// src/entities/route.ts\nimport invariant3 from \"tiny-invariant\";\nimport { Price as Price2 } from \"@pancakeswap/swap-sdk-core\";\nvar Route = class {\n  constructor(pairs, input, output) {\n    this._midPrice = null;\n    invariant3(pairs.length > 0, \"PAIRS\");\n    const chainId = pairs[0].chainId;\n    invariant3(pairs.every(pair => pair.chainId === chainId), \"CHAIN_IDS\");\n    const wrappedInput = input.wrapped;\n    invariant3(pairs[0].involvesToken(wrappedInput), \"INPUT\");\n    invariant3(typeof output === \"undefined\" || pairs[pairs.length - 1].involvesToken(output.wrapped), \"OUTPUT\");\n    const path = [wrappedInput];\n    for (const [i, pair] of pairs.entries()) {\n      const currentInput = path[i];\n      invariant3(currentInput.equals(pair.token0) || currentInput.equals(pair.token1), \"PATH\");\n      const output2 = currentInput.equals(pair.token0) ? pair.token1 : pair.token0;\n      path.push(output2);\n    }\n    this.pairs = pairs;\n    this.path = path;\n    this.input = input;\n    this.output = output;\n  }\n  get midPrice() {\n    if (this._midPrice !== null) return this._midPrice;\n    const prices = [];\n    for (const [i, pair] of this.pairs.entries()) {\n      prices.push(this.path[i].equals(pair.token0) ? new Price2(pair.reserve0.currency, pair.reserve1.currency, pair.reserve0.quotient, pair.reserve1.quotient) : new Price2(pair.reserve1.currency, pair.reserve0.currency, pair.reserve1.quotient, pair.reserve0.quotient));\n    }\n    const reduced = prices.slice(1).reduce((accumulator, currentValue) => accumulator.multiply(currentValue), prices[0]);\n    return this._midPrice = new Price2(this.input, this.output, reduced.denominator, reduced.numerator);\n  }\n  get chainId() {\n    return this.pairs[0].chainId;\n  }\n};\n\n// src/entities/trade.ts\nimport invariant4 from \"tiny-invariant\";\nimport { ONE as ONE2, TradeType, ZERO as ZERO2, CurrencyAmount as CurrencyAmount2, Fraction, Price as Price3, sortedInsert, computePriceImpact } from \"@pancakeswap/swap-sdk-core\";\nfunction inputOutputComparator(a, b) {\n  invariant4(a.inputAmount.currency.equals(b.inputAmount.currency), \"INPUT_CURRENCY\");\n  invariant4(a.outputAmount.currency.equals(b.outputAmount.currency), \"OUTPUT_CURRENCY\");\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0;\n    }\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1;\n    }\n    return 1;\n  }\n  if (a.outputAmount.lessThan(b.outputAmount)) {\n    return 1;\n  }\n  return -1;\n}\nfunction tradeComparator(a, b) {\n  const ioComp = inputOutputComparator(a, b);\n  if (ioComp !== 0) {\n    return ioComp;\n  }\n  if (a.priceImpact.lessThan(b.priceImpact)) {\n    return -1;\n  }\n  if (a.priceImpact.greaterThan(b.priceImpact)) {\n    return 1;\n  }\n  return a.route.path.length - b.route.path.length;\n}\nvar Trade = class {\n  static exactIn(route, amountIn) {\n    return new Trade(route, amountIn, TradeType.EXACT_INPUT);\n  }\n  static exactOut(route, amountOut) {\n    return new Trade(route, amountOut, TradeType.EXACT_OUTPUT);\n  }\n  constructor(route, amount, tradeType) {\n    this.route = route;\n    this.tradeType = tradeType;\n    const tokenAmounts = new Array(route.path.length);\n    if (tradeType === TradeType.EXACT_INPUT) {\n      invariant4(amount.currency.equals(route.input), \"INPUT\");\n      tokenAmounts[0] = amount.wrapped;\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pair = route.pairs[i];\n        const [outputAmount] = pair.getOutputAmount(tokenAmounts[i]);\n        tokenAmounts[i + 1] = outputAmount;\n      }\n      this.inputAmount = CurrencyAmount2.fromFractionalAmount(route.input, amount.numerator, amount.denominator);\n      this.outputAmount = CurrencyAmount2.fromFractionalAmount(route.output, tokenAmounts[tokenAmounts.length - 1].numerator, tokenAmounts[tokenAmounts.length - 1].denominator);\n    } else {\n      invariant4(amount.currency.equals(route.output), \"OUTPUT\");\n      tokenAmounts[tokenAmounts.length - 1] = amount.wrapped;\n      for (let i = route.path.length - 1; i > 0; i--) {\n        const pair = route.pairs[i - 1];\n        const [inputAmount] = pair.getInputAmount(tokenAmounts[i]);\n        tokenAmounts[i - 1] = inputAmount;\n      }\n      this.inputAmount = CurrencyAmount2.fromFractionalAmount(route.input, tokenAmounts[0].numerator, tokenAmounts[0].denominator);\n      this.outputAmount = CurrencyAmount2.fromFractionalAmount(route.output, amount.numerator, amount.denominator);\n    }\n    this.executionPrice = new Price3(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.quotient, this.outputAmount.quotient);\n    this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount);\n  }\n  minimumAmountOut(slippageTolerance) {\n    invariant4(!slippageTolerance.lessThan(ZERO2), \"SLIPPAGE_TOLERANCE\");\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return this.outputAmount;\n    }\n    const slippageAdjustedAmountOut = new Fraction(ONE2).add(slippageTolerance).invert().multiply(this.outputAmount.quotient).quotient;\n    return CurrencyAmount2.fromRawAmount(this.outputAmount.currency, slippageAdjustedAmountOut);\n  }\n  maximumAmountIn(slippageTolerance) {\n    invariant4(!slippageTolerance.lessThan(ZERO2), \"SLIPPAGE_TOLERANCE\");\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return this.inputAmount;\n    }\n    const slippageAdjustedAmountIn = new Fraction(ONE2).add(slippageTolerance).multiply(this.inputAmount.quotient).quotient;\n    return CurrencyAmount2.fromRawAmount(this.inputAmount.currency, slippageAdjustedAmountIn);\n  }\n  static bestTradeExactIn(pairs, currencyAmountIn, currencyOut) {\n    let {\n      maxNumResults = 3,\n      maxHops = 3\n    } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let currentPairs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n    let nextAmountIn = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : currencyAmountIn;\n    let bestTrades = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];\n    invariant4(pairs.length > 0, \"PAIRS\");\n    invariant4(maxHops > 0, \"MAX_HOPS\");\n    invariant4(currencyAmountIn === nextAmountIn || currentPairs.length > 0, \"INVALID_RECURSION\");\n    const amountIn = nextAmountIn.wrapped;\n    const tokenOut = currencyOut.wrapped;\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i];\n      if (!pair.token0.equals(amountIn.currency) && !pair.token1.equals(amountIn.currency)) continue;\n      if (pair.reserve0.equalTo(ZERO2) || pair.reserve1.equalTo(ZERO2)) continue;\n      let amountOut;\n      try {\n        ;\n        [amountOut] = pair.getOutputAmount(amountIn);\n      } catch (error) {\n        if (error.isInsufficientInputAmountError) {\n          continue;\n        }\n        throw error;\n      }\n      if (amountOut.currency.equals(tokenOut)) {\n        sortedInsert(bestTrades, new Trade(new Route([...currentPairs, pair], currencyAmountIn.currency, currencyOut), currencyAmountIn, TradeType.EXACT_INPUT), maxNumResults, tradeComparator);\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length));\n        Trade.bestTradeExactIn(pairsExcludingThisPair, currencyAmountIn, currencyOut, {\n          maxNumResults,\n          maxHops: maxHops - 1\n        }, [...currentPairs, pair], amountOut, bestTrades);\n      }\n    }\n    return bestTrades;\n  }\n  worstExecutionPrice(slippageTolerance) {\n    return new Price3(this.inputAmount.currency, this.outputAmount.currency, this.maximumAmountIn(slippageTolerance).quotient, this.minimumAmountOut(slippageTolerance).quotient);\n  }\n  static bestTradeExactOut(pairs, currencyIn, currencyAmountOut) {\n    let {\n      maxNumResults = 3,\n      maxHops = 3\n    } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let currentPairs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n    let nextAmountOut = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : currencyAmountOut;\n    let bestTrades = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];\n    invariant4(pairs.length > 0, \"PAIRS\");\n    invariant4(maxHops > 0, \"MAX_HOPS\");\n    invariant4(currencyAmountOut === nextAmountOut || currentPairs.length > 0, \"INVALID_RECURSION\");\n    const amountOut = nextAmountOut.wrapped;\n    const tokenIn = currencyIn.wrapped;\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i];\n      if (!pair.token0.equals(amountOut.currency) && !pair.token1.equals(amountOut.currency)) continue;\n      if (pair.reserve0.equalTo(ZERO2) || pair.reserve1.equalTo(ZERO2)) continue;\n      let amountIn;\n      try {\n        ;\n        [amountIn] = pair.getInputAmount(amountOut);\n      } catch (error) {\n        if (error.isInsufficientReservesError) {\n          continue;\n        }\n        throw error;\n      }\n      if (amountIn.currency.equals(tokenIn)) {\n        sortedInsert(bestTrades, new Trade(new Route([pair, ...currentPairs], currencyIn, currencyAmountOut.currency), currencyAmountOut, TradeType.EXACT_OUTPUT), maxNumResults, tradeComparator);\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length));\n        Trade.bestTradeExactOut(pairsExcludingThisPair, currencyIn, currencyAmountOut, {\n          maxNumResults,\n          maxHops: maxHops - 1\n        }, [pair, ...currentPairs], amountIn, bestTrades);\n      }\n    }\n    return bestTrades;\n  }\n};\n\n// src/entities/native.ts\nimport invariant5 from \"tiny-invariant\";\nimport { NativeCurrency } from \"@pancakeswap/swap-sdk-core\";\nvar _Native = class extends NativeCurrency {\n  constructor(_ref2) {\n    let {\n      chainId,\n      decimals,\n      name,\n      symbol\n    } = _ref2;\n    super(chainId, decimals, symbol, name);\n  }\n  get wrapped() {\n    const wnative = WNATIVE[this.chainId];\n    invariant5(!!wnative, \"WRAPPED\");\n    return wnative;\n  }\n  static onChain(chainId) {\n    if (chainId in this.cache) {\n      return this.cache[chainId];\n    }\n    invariant5(!!NATIVE[chainId], \"NATIVE_CURRENCY\");\n    const {\n      decimals,\n      name,\n      symbol\n    } = NATIVE[chainId];\n    return this.cache[chainId] = new _Native({\n      chainId,\n      decimals,\n      symbol,\n      name\n    });\n  }\n  equals(other) {\n    return other.isNative && other.chainId === this.chainId;\n  }\n};\nvar Native = _Native;\nNative.cache = {};\n\n// src/router.ts\nimport { TradeType as TradeType2 } from \"@pancakeswap/swap-sdk-core\";\nimport invariant6 from \"tiny-invariant\";\nfunction toHex(currencyAmount) {\n  return `0x${currencyAmount.quotient.toString(16)}`;\n}\nvar ZERO_HEX = \"0x0\";\nvar Router = class {\n  constructor() {}\n  static swapCallParameters(trade, options) {\n    const etherIn = trade.inputAmount.currency.isNative;\n    const etherOut = trade.outputAmount.currency.isNative;\n    invariant6(!(etherIn && etherOut), \"ETHER_IN_OUT\");\n    invariant6(!(\"ttl\" in options) || options.ttl > 0, \"TTL\");\n    const to = validateAndParseAddress(options.recipient);\n    const amountIn = toHex(trade.maximumAmountIn(options.allowedSlippage));\n    const amountOut = toHex(trade.minimumAmountOut(options.allowedSlippage));\n    const path = trade.route.path.map(token => token.address);\n    const deadline = \"ttl\" in options ? `0x${(Math.floor(new Date().getTime() / 1e3) + options.ttl).toString(16)}` : `0x${options.deadline.toString(16)}`;\n    const useFeeOnTransfer = Boolean(options.feeOnTransfer);\n    let methodName;\n    let args;\n    let value;\n    switch (trade.tradeType) {\n      case TradeType2.EXACT_INPUT:\n        if (etherIn) {\n          methodName = useFeeOnTransfer ? \"swapExactETHForTokensSupportingFeeOnTransferTokens\" : \"swapExactETHForTokens\";\n          args = [amountOut, path, to, deadline];\n          value = amountIn;\n        } else if (etherOut) {\n          methodName = useFeeOnTransfer ? \"swapExactTokensForETHSupportingFeeOnTransferTokens\" : \"swapExactTokensForETH\";\n          args = [amountIn, amountOut, path, to, deadline];\n          value = ZERO_HEX;\n        } else {\n          methodName = useFeeOnTransfer ? \"swapExactTokensForTokensSupportingFeeOnTransferTokens\" : \"swapExactTokensForTokens\";\n          args = [amountIn, amountOut, path, to, deadline];\n          value = ZERO_HEX;\n        }\n        break;\n      case TradeType2.EXACT_OUTPUT:\n        invariant6(!useFeeOnTransfer, \"EXACT_OUT_FOT\");\n        if (etherIn) {\n          methodName = \"swapETHForExactTokens\";\n          args = [amountOut, path, to, deadline];\n          value = amountIn;\n        } else if (etherOut) {\n          methodName = \"swapTokensForExactETH\";\n          args = [amountOut, amountIn, path, to, deadline];\n          value = ZERO_HEX;\n        } else {\n          methodName = \"swapTokensForExactTokens\";\n          args = [amountOut, amountIn, path, to, deadline];\n          value = ZERO_HEX;\n        }\n        break;\n    }\n    return {\n      methodName,\n      args,\n      value\n    };\n  }\n};\n\n// src/index.ts\nexport * from \"@pancakeswap/swap-sdk-core\";\nexport { ChainId, ERC20Token, FACTORY_ADDRESS, FACTORY_ADDRESS_MAP, INIT_CODE_HASH, INIT_CODE_HASH_MAP, JSBI2 as JSBI, NATIVE, Native, ONE_HUNDRED_PERCENT, Pair, Route, Router, Trade, WBNB, WETH9, WNATIVE, ZERO_PERCENT, computePairAddress, inputOutputComparator, isTradeBetter, tradeComparator };","map":{"version":3,"names":["JSBI2","Percent","Token","getAddress","invariant","warning","validateAndParseAddress","address","checksummedAddress","error","ERC20Token","constructor","chainId","decimals","symbol","name","projectLink","ChainId","ChainId2","ZERO_PERCENT","ONE_HUNDRED_PERCENT","FACTORY_ADDRESS","FACTORY_ADDRESS_ETH","FACTORY_ADDRESS_MAP","INIT_CODE_HASH","INIT_CODE_HASH_ETH","INIT_CODE_HASH_MAP","WETH9","WBNB","WNATIVE","NATIVE","isTradeBetter","tradeA","tradeB","minimumDelta","arguments","length","undefined","tradeType","inputAmount","currency","equals","outputAmount","Error","equalTo","executionPrice","lessThan","asFraction","multiply","add","InsufficientInputAmountError","InsufficientReservesError","sqrt","CurrencyAmount","Price","FIVE","ONE","ZERO","_10000","_9975","MINIMUM_LIQUIDITY","getCreate2Address","keccak256","pack","JSBI","invariant2","PAIR_ADDRESS_CACHE","composeKey","token0","token1","computePairAddress","_ref","factoryAddress","tokenA","tokenB","sortsBefore","key","Pair","currencyAmountA","tokenAmountB","tokenAmounts","liquidityToken","involvesToken","token","token0Price","result","divide","denominator","numerator","token1Price","priceOf","reserve0","reserve1","reserveOf","getOutputAmount","equal","quotient","inputReserve","outputReserve","inputAmountWithFee","fromRawAmount","subtract","getInputAmount","greaterThanOrEqual","getLiquidityMinted","totalSupply","tokenAmountA","liquidity","amount0","amount1","lessThanOrEqual","greaterThan","getLiquidityValue","feeOn","kLast","totalSupplyAdjusted","kLastParsed","BigInt","rootK","rootKLast","feeLiquidity","invariant3","Price2","Route","pairs","input","output","_midPrice","every","pair","wrappedInput","wrapped","path","i","entries","currentInput","output2","push","midPrice","prices","reduced","slice","reduce","accumulator","currentValue","invariant4","ONE2","TradeType","ZERO2","CurrencyAmount2","Fraction","Price3","sortedInsert","computePriceImpact","inputOutputComparator","a","b","tradeComparator","ioComp","priceImpact","route","Trade","exactIn","amountIn","EXACT_INPUT","exactOut","amountOut","EXACT_OUTPUT","amount","Array","fromFractionalAmount","minimumAmountOut","slippageTolerance","slippageAdjustedAmountOut","invert","maximumAmountIn","slippageAdjustedAmountIn","bestTradeExactIn","currencyAmountIn","currencyOut","maxNumResults","maxHops","currentPairs","nextAmountIn","bestTrades","tokenOut","isInsufficientInputAmountError","pairsExcludingThisPair","concat","worstExecutionPrice","bestTradeExactOut","currencyIn","currencyAmountOut","nextAmountOut","tokenIn","isInsufficientReservesError","invariant5","NativeCurrency","_Native","_ref2","wnative","onChain","cache","other","isNative","Native","TradeType2","invariant6","toHex","currencyAmount","toString","ZERO_HEX","Router","swapCallParameters","trade","options","etherIn","etherOut","ttl","to","recipient","allowedSlippage","map","deadline","Math","floor","Date","getTime","useFeeOnTransfer","Boolean","feeOnTransfer","methodName","args","value"],"sources":["D:/dsdc-dashboard/node_modules/@pancakeswap/sdk/dist/index.mjs"],"sourcesContent":["// src/index.ts\nimport JSBI2 from \"jsbi\";\n\n// src/constants.ts\nimport { Percent } from \"@pancakeswap/swap-sdk-core\";\n\n// src/entities/token.ts\nimport { Token } from \"@pancakeswap/swap-sdk-core\";\n\n// src/utils.ts\nimport { getAddress } from \"@ethersproject/address\";\nimport invariant from \"tiny-invariant\";\nimport warning from \"tiny-warning\";\nfunction validateAndParseAddress(address) {\n  try {\n    const checksummedAddress = getAddress(address);\n    warning(address === checksummedAddress, `${address} is not checksummed.`);\n    return checksummedAddress;\n  } catch (error) {\n    invariant(false, `${address} is not a valid address.`);\n  }\n}\n\n// src/entities/token.ts\nvar ERC20Token = class extends Token {\n  constructor(chainId, address, decimals, symbol, name, projectLink) {\n    super(chainId, validateAndParseAddress(address), decimals, symbol, name, projectLink);\n  }\n};\n\n// src/constants.ts\nvar ChainId = /* @__PURE__ */ ((ChainId2) => {\n  ChainId2[ChainId2[\"ETHEREUM\"] = 1] = \"ETHEREUM\";\n  ChainId2[ChainId2[\"GOERLI\"] = 5] = \"GOERLI\";\n  ChainId2[ChainId2[\"BSC\"] = 56] = \"BSC\";\n  ChainId2[ChainId2[\"BSC_TESTNET\"] = 97] = \"BSC_TESTNET\";\n  return ChainId2;\n})(ChainId || {});\nvar ZERO_PERCENT = new Percent(\"0\");\nvar ONE_HUNDRED_PERCENT = new Percent(\"1\");\nvar FACTORY_ADDRESS = \"0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73\";\nvar FACTORY_ADDRESS_ETH = \"0x1097053Fd2ea711dad45caCcc45EfF7548fCB362\";\nvar FACTORY_ADDRESS_MAP = {\n  [1 /* ETHEREUM */]: FACTORY_ADDRESS_ETH,\n  [5 /* GOERLI */]: FACTORY_ADDRESS_ETH,\n  [56 /* BSC */]: FACTORY_ADDRESS,\n  [97 /* BSC_TESTNET */]: \"0x6725f303b657a9451d8ba641348b6761a6cc7a17\"\n};\nvar INIT_CODE_HASH = \"0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5\";\nvar INIT_CODE_HASH_ETH = \"0x57224589c67f3f30a6b0d7a1b54cf3153ab84563bc609ef41dfb34f8b2974d2d\";\nvar INIT_CODE_HASH_MAP = {\n  [1 /* ETHEREUM */]: INIT_CODE_HASH_ETH,\n  [5 /* GOERLI */]: INIT_CODE_HASH_ETH,\n  [56 /* BSC */]: INIT_CODE_HASH,\n  [97 /* BSC_TESTNET */]: \"0xd0d4c4cd0848c93cb4fd1f498d7013ee6bfb25783ea21593d5834f5d250ece66\"\n};\nvar WETH9 = {\n  [1 /* ETHEREUM */]: new ERC20Token(1 /* ETHEREUM */, \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\", 18, \"WETH\", \"Wrapped Ether\", \"https://weth.io\"),\n  [5 /* GOERLI */]: new ERC20Token(5 /* GOERLI */, \"0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6\", 18, \"WETH\", \"Wrapped Ether\", \"https://weth.io\")\n};\nvar WBNB = {\n  [1 /* ETHEREUM */]: new ERC20Token(1 /* ETHEREUM */, \"0x418D75f65a02b3D53B2418FB8E1fe493759c7605\", 18, \"WBNB\", \"Wrapped BNB\", \"https://www.binance.org\"),\n  [56 /* BSC */]: new ERC20Token(56 /* BSC */, \"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\", 18, \"WBNB\", \"Wrapped BNB\", \"https://www.binance.org\"),\n  [97 /* BSC_TESTNET */]: new ERC20Token(97 /* BSC_TESTNET */, \"0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd\", 18, \"WBNB\", \"Wrapped BNB\", \"https://www.binance.org\")\n};\nvar WNATIVE = {\n  [1 /* ETHEREUM */]: WETH9[1 /* ETHEREUM */],\n  [5 /* GOERLI */]: WETH9[5 /* GOERLI */],\n  [56 /* BSC */]: WBNB[56 /* BSC */],\n  [97 /* BSC_TESTNET */]: WBNB[97 /* BSC_TESTNET */]\n};\nvar NATIVE = {\n  [1 /* ETHEREUM */]: { name: \"Ether\", symbol: \"ETH\", decimals: 18 },\n  [5 /* GOERLI */]: { name: \"Goerli Ether\", symbol: \"GOR\", decimals: 18 },\n  [56 /* BSC */]: {\n    name: \"Binance Chain Native Token\",\n    symbol: \"BNB\",\n    decimals: 18\n  },\n  [97 /* BSC_TESTNET */]: {\n    name: \"Binance Chain Native Token\",\n    symbol: \"tBNB\",\n    decimals: 18\n  }\n};\n\n// src/trade.ts\nfunction isTradeBetter(tradeA, tradeB, minimumDelta = ZERO_PERCENT) {\n  if (tradeA && !tradeB)\n    return false;\n  if (tradeB && !tradeA)\n    return true;\n  if (!tradeA || !tradeB)\n    return void 0;\n  if (tradeA.tradeType !== tradeB.tradeType || !tradeA.inputAmount.currency.equals(tradeB.inputAmount.currency) || !tradeA.outputAmount.currency.equals(tradeB.outputAmount.currency)) {\n    throw new Error(\"Trades are not comparable\");\n  }\n  if (minimumDelta.equalTo(ZERO_PERCENT)) {\n    return tradeA.executionPrice.lessThan(tradeB.executionPrice);\n  }\n  return tradeA.executionPrice.asFraction.multiply(minimumDelta.add(ONE_HUNDRED_PERCENT)).lessThan(tradeB.executionPrice);\n}\n\n// src/entities/pair.ts\nimport {\n  InsufficientInputAmountError,\n  InsufficientReservesError,\n  sqrt,\n  CurrencyAmount,\n  Price,\n  FIVE,\n  ONE,\n  ZERO,\n  _10000,\n  _9975,\n  MINIMUM_LIQUIDITY\n} from \"@pancakeswap/swap-sdk-core\";\nimport { getCreate2Address } from \"@ethersproject/address\";\nimport { keccak256, pack } from \"@ethersproject/solidity\";\nimport JSBI from \"jsbi\";\nimport invariant2 from \"tiny-invariant\";\nvar PAIR_ADDRESS_CACHE = {};\nvar composeKey = (token0, token1) => `${token0.chainId}-${token0.address}-${token1.address}`;\nvar computePairAddress = ({\n  factoryAddress,\n  tokenA,\n  tokenB\n}) => {\n  const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];\n  const key = composeKey(token0, token1);\n  if ((PAIR_ADDRESS_CACHE == null ? void 0 : PAIR_ADDRESS_CACHE[key]) === void 0) {\n    PAIR_ADDRESS_CACHE = {\n      ...PAIR_ADDRESS_CACHE,\n      [key]: getCreate2Address(factoryAddress, keccak256([\"bytes\"], [pack([\"address\", \"address\"], [token0.address, token1.address])]), INIT_CODE_HASH_MAP[token0.chainId])\n    };\n  }\n  return PAIR_ADDRESS_CACHE[key];\n};\nvar Pair = class {\n  static getAddress(tokenA, tokenB) {\n    return computePairAddress({ factoryAddress: FACTORY_ADDRESS_MAP[tokenA.chainId], tokenA, tokenB });\n  }\n  constructor(currencyAmountA, tokenAmountB) {\n    const tokenAmounts = currencyAmountA.currency.sortsBefore(tokenAmountB.currency) ? [currencyAmountA, tokenAmountB] : [tokenAmountB, currencyAmountA];\n    this.liquidityToken = new ERC20Token(tokenAmounts[0].currency.chainId, Pair.getAddress(tokenAmounts[0].currency, tokenAmounts[1].currency), 18, \"Cake-LP\", \"Pancake LPs\");\n    this.tokenAmounts = tokenAmounts;\n  }\n  involvesToken(token) {\n    return token.equals(this.token0) || token.equals(this.token1);\n  }\n  get token0Price() {\n    const result = this.tokenAmounts[1].divide(this.tokenAmounts[0]);\n    return new Price(this.token0, this.token1, result.denominator, result.numerator);\n  }\n  get token1Price() {\n    const result = this.tokenAmounts[0].divide(this.tokenAmounts[1]);\n    return new Price(this.token1, this.token0, result.denominator, result.numerator);\n  }\n  priceOf(token) {\n    invariant2(this.involvesToken(token), \"TOKEN\");\n    return token.equals(this.token0) ? this.token0Price : this.token1Price;\n  }\n  get chainId() {\n    return this.token0.chainId;\n  }\n  get token0() {\n    return this.tokenAmounts[0].currency;\n  }\n  get token1() {\n    return this.tokenAmounts[1].currency;\n  }\n  get reserve0() {\n    return this.tokenAmounts[0];\n  }\n  get reserve1() {\n    return this.tokenAmounts[1];\n  }\n  reserveOf(token) {\n    invariant2(this.involvesToken(token), \"TOKEN\");\n    return token.equals(this.token0) ? this.reserve0 : this.reserve1;\n  }\n  getOutputAmount(inputAmount) {\n    invariant2(this.involvesToken(inputAmount.currency), \"TOKEN\");\n    if (JSBI.equal(this.reserve0.quotient, ZERO) || JSBI.equal(this.reserve1.quotient, ZERO)) {\n      throw new InsufficientReservesError();\n    }\n    const inputReserve = this.reserveOf(inputAmount.currency);\n    const outputReserve = this.reserveOf(inputAmount.currency.equals(this.token0) ? this.token1 : this.token0);\n    const inputAmountWithFee = JSBI.multiply(inputAmount.quotient, _9975);\n    const numerator = JSBI.multiply(inputAmountWithFee, outputReserve.quotient);\n    const denominator = JSBI.add(JSBI.multiply(inputReserve.quotient, _10000), inputAmountWithFee);\n    const outputAmount = CurrencyAmount.fromRawAmount(inputAmount.currency.equals(this.token0) ? this.token1 : this.token0, JSBI.divide(numerator, denominator));\n    if (JSBI.equal(outputAmount.quotient, ZERO)) {\n      throw new InsufficientInputAmountError();\n    }\n    return [outputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))];\n  }\n  getInputAmount(outputAmount) {\n    invariant2(this.involvesToken(outputAmount.currency), \"TOKEN\");\n    if (JSBI.equal(this.reserve0.quotient, ZERO) || JSBI.equal(this.reserve1.quotient, ZERO) || JSBI.greaterThanOrEqual(outputAmount.quotient, this.reserveOf(outputAmount.currency).quotient)) {\n      throw new InsufficientReservesError();\n    }\n    const outputReserve = this.reserveOf(outputAmount.currency);\n    const inputReserve = this.reserveOf(outputAmount.currency.equals(this.token0) ? this.token1 : this.token0);\n    const numerator = JSBI.multiply(JSBI.multiply(inputReserve.quotient, outputAmount.quotient), _10000);\n    const denominator = JSBI.multiply(JSBI.subtract(outputReserve.quotient, outputAmount.quotient), _9975);\n    const inputAmount = CurrencyAmount.fromRawAmount(outputAmount.currency.equals(this.token0) ? this.token1 : this.token0, JSBI.add(JSBI.divide(numerator, denominator), ONE));\n    return [inputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))];\n  }\n  getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB) {\n    invariant2(totalSupply.currency.equals(this.liquidityToken), \"LIQUIDITY\");\n    const tokenAmounts = tokenAmountA.currency.sortsBefore(tokenAmountB.currency) ? [tokenAmountA, tokenAmountB] : [tokenAmountB, tokenAmountA];\n    invariant2(tokenAmounts[0].currency.equals(this.token0) && tokenAmounts[1].currency.equals(this.token1), \"TOKEN\");\n    let liquidity;\n    if (JSBI.equal(totalSupply.quotient, ZERO)) {\n      liquidity = JSBI.subtract(sqrt(JSBI.multiply(tokenAmounts[0].quotient, tokenAmounts[1].quotient)), MINIMUM_LIQUIDITY);\n    } else {\n      const amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].quotient, totalSupply.quotient), this.reserve0.quotient);\n      const amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].quotient, totalSupply.quotient), this.reserve1.quotient);\n      liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1;\n    }\n    if (!JSBI.greaterThan(liquidity, ZERO)) {\n      throw new InsufficientInputAmountError();\n    }\n    return CurrencyAmount.fromRawAmount(this.liquidityToken, liquidity);\n  }\n  getLiquidityValue(token, totalSupply, liquidity, feeOn = false, kLast) {\n    invariant2(this.involvesToken(token), \"TOKEN\");\n    invariant2(totalSupply.currency.equals(this.liquidityToken), \"TOTAL_SUPPLY\");\n    invariant2(liquidity.currency.equals(this.liquidityToken), \"LIQUIDITY\");\n    invariant2(JSBI.lessThanOrEqual(liquidity.quotient, totalSupply.quotient), \"LIQUIDITY\");\n    let totalSupplyAdjusted;\n    if (!feeOn) {\n      totalSupplyAdjusted = totalSupply;\n    } else {\n      invariant2(!!kLast, \"K_LAST\");\n      const kLastParsed = JSBI.BigInt(kLast);\n      if (!JSBI.equal(kLastParsed, ZERO)) {\n        const rootK = sqrt(JSBI.multiply(this.reserve0.quotient, this.reserve1.quotient));\n        const rootKLast = sqrt(kLastParsed);\n        if (JSBI.greaterThan(rootK, rootKLast)) {\n          const numerator = JSBI.multiply(totalSupply.quotient, JSBI.subtract(rootK, rootKLast));\n          const denominator = JSBI.add(JSBI.multiply(rootK, FIVE), rootKLast);\n          const feeLiquidity = JSBI.divide(numerator, denominator);\n          totalSupplyAdjusted = totalSupply.add(CurrencyAmount.fromRawAmount(this.liquidityToken, feeLiquidity));\n        } else {\n          totalSupplyAdjusted = totalSupply;\n        }\n      } else {\n        totalSupplyAdjusted = totalSupply;\n      }\n    }\n    return CurrencyAmount.fromRawAmount(token, JSBI.divide(JSBI.multiply(liquidity.quotient, this.reserveOf(token).quotient), totalSupplyAdjusted.quotient));\n  }\n};\n\n// src/entities/route.ts\nimport invariant3 from \"tiny-invariant\";\nimport { Price as Price2 } from \"@pancakeswap/swap-sdk-core\";\nvar Route = class {\n  constructor(pairs, input, output) {\n    this._midPrice = null;\n    invariant3(pairs.length > 0, \"PAIRS\");\n    const chainId = pairs[0].chainId;\n    invariant3(pairs.every((pair) => pair.chainId === chainId), \"CHAIN_IDS\");\n    const wrappedInput = input.wrapped;\n    invariant3(pairs[0].involvesToken(wrappedInput), \"INPUT\");\n    invariant3(typeof output === \"undefined\" || pairs[pairs.length - 1].involvesToken(output.wrapped), \"OUTPUT\");\n    const path = [wrappedInput];\n    for (const [i, pair] of pairs.entries()) {\n      const currentInput = path[i];\n      invariant3(currentInput.equals(pair.token0) || currentInput.equals(pair.token1), \"PATH\");\n      const output2 = currentInput.equals(pair.token0) ? pair.token1 : pair.token0;\n      path.push(output2);\n    }\n    this.pairs = pairs;\n    this.path = path;\n    this.input = input;\n    this.output = output;\n  }\n  get midPrice() {\n    if (this._midPrice !== null)\n      return this._midPrice;\n    const prices = [];\n    for (const [i, pair] of this.pairs.entries()) {\n      prices.push(this.path[i].equals(pair.token0) ? new Price2(pair.reserve0.currency, pair.reserve1.currency, pair.reserve0.quotient, pair.reserve1.quotient) : new Price2(pair.reserve1.currency, pair.reserve0.currency, pair.reserve1.quotient, pair.reserve0.quotient));\n    }\n    const reduced = prices.slice(1).reduce((accumulator, currentValue) => accumulator.multiply(currentValue), prices[0]);\n    return this._midPrice = new Price2(this.input, this.output, reduced.denominator, reduced.numerator);\n  }\n  get chainId() {\n    return this.pairs[0].chainId;\n  }\n};\n\n// src/entities/trade.ts\nimport invariant4 from \"tiny-invariant\";\nimport {\n  ONE as ONE2,\n  TradeType,\n  ZERO as ZERO2,\n  CurrencyAmount as CurrencyAmount2,\n  Fraction,\n  Price as Price3,\n  sortedInsert,\n  computePriceImpact\n} from \"@pancakeswap/swap-sdk-core\";\nfunction inputOutputComparator(a, b) {\n  invariant4(a.inputAmount.currency.equals(b.inputAmount.currency), \"INPUT_CURRENCY\");\n  invariant4(a.outputAmount.currency.equals(b.outputAmount.currency), \"OUTPUT_CURRENCY\");\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0;\n    }\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1;\n    }\n    return 1;\n  }\n  if (a.outputAmount.lessThan(b.outputAmount)) {\n    return 1;\n  }\n  return -1;\n}\nfunction tradeComparator(a, b) {\n  const ioComp = inputOutputComparator(a, b);\n  if (ioComp !== 0) {\n    return ioComp;\n  }\n  if (a.priceImpact.lessThan(b.priceImpact)) {\n    return -1;\n  }\n  if (a.priceImpact.greaterThan(b.priceImpact)) {\n    return 1;\n  }\n  return a.route.path.length - b.route.path.length;\n}\nvar Trade = class {\n  static exactIn(route, amountIn) {\n    return new Trade(route, amountIn, TradeType.EXACT_INPUT);\n  }\n  static exactOut(route, amountOut) {\n    return new Trade(route, amountOut, TradeType.EXACT_OUTPUT);\n  }\n  constructor(route, amount, tradeType) {\n    this.route = route;\n    this.tradeType = tradeType;\n    const tokenAmounts = new Array(route.path.length);\n    if (tradeType === TradeType.EXACT_INPUT) {\n      invariant4(amount.currency.equals(route.input), \"INPUT\");\n      tokenAmounts[0] = amount.wrapped;\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pair = route.pairs[i];\n        const [outputAmount] = pair.getOutputAmount(tokenAmounts[i]);\n        tokenAmounts[i + 1] = outputAmount;\n      }\n      this.inputAmount = CurrencyAmount2.fromFractionalAmount(route.input, amount.numerator, amount.denominator);\n      this.outputAmount = CurrencyAmount2.fromFractionalAmount(route.output, tokenAmounts[tokenAmounts.length - 1].numerator, tokenAmounts[tokenAmounts.length - 1].denominator);\n    } else {\n      invariant4(amount.currency.equals(route.output), \"OUTPUT\");\n      tokenAmounts[tokenAmounts.length - 1] = amount.wrapped;\n      for (let i = route.path.length - 1; i > 0; i--) {\n        const pair = route.pairs[i - 1];\n        const [inputAmount] = pair.getInputAmount(tokenAmounts[i]);\n        tokenAmounts[i - 1] = inputAmount;\n      }\n      this.inputAmount = CurrencyAmount2.fromFractionalAmount(route.input, tokenAmounts[0].numerator, tokenAmounts[0].denominator);\n      this.outputAmount = CurrencyAmount2.fromFractionalAmount(route.output, amount.numerator, amount.denominator);\n    }\n    this.executionPrice = new Price3(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.quotient, this.outputAmount.quotient);\n    this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount);\n  }\n  minimumAmountOut(slippageTolerance) {\n    invariant4(!slippageTolerance.lessThan(ZERO2), \"SLIPPAGE_TOLERANCE\");\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return this.outputAmount;\n    }\n    const slippageAdjustedAmountOut = new Fraction(ONE2).add(slippageTolerance).invert().multiply(this.outputAmount.quotient).quotient;\n    return CurrencyAmount2.fromRawAmount(this.outputAmount.currency, slippageAdjustedAmountOut);\n  }\n  maximumAmountIn(slippageTolerance) {\n    invariant4(!slippageTolerance.lessThan(ZERO2), \"SLIPPAGE_TOLERANCE\");\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return this.inputAmount;\n    }\n    const slippageAdjustedAmountIn = new Fraction(ONE2).add(slippageTolerance).multiply(this.inputAmount.quotient).quotient;\n    return CurrencyAmount2.fromRawAmount(this.inputAmount.currency, slippageAdjustedAmountIn);\n  }\n  static bestTradeExactIn(pairs, currencyAmountIn, currencyOut, { maxNumResults = 3, maxHops = 3 } = {}, currentPairs = [], nextAmountIn = currencyAmountIn, bestTrades = []) {\n    invariant4(pairs.length > 0, \"PAIRS\");\n    invariant4(maxHops > 0, \"MAX_HOPS\");\n    invariant4(currencyAmountIn === nextAmountIn || currentPairs.length > 0, \"INVALID_RECURSION\");\n    const amountIn = nextAmountIn.wrapped;\n    const tokenOut = currencyOut.wrapped;\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i];\n      if (!pair.token0.equals(amountIn.currency) && !pair.token1.equals(amountIn.currency))\n        continue;\n      if (pair.reserve0.equalTo(ZERO2) || pair.reserve1.equalTo(ZERO2))\n        continue;\n      let amountOut;\n      try {\n        ;\n        [amountOut] = pair.getOutputAmount(amountIn);\n      } catch (error) {\n        if (error.isInsufficientInputAmountError) {\n          continue;\n        }\n        throw error;\n      }\n      if (amountOut.currency.equals(tokenOut)) {\n        sortedInsert(bestTrades, new Trade(new Route([...currentPairs, pair], currencyAmountIn.currency, currencyOut), currencyAmountIn, TradeType.EXACT_INPUT), maxNumResults, tradeComparator);\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length));\n        Trade.bestTradeExactIn(pairsExcludingThisPair, currencyAmountIn, currencyOut, {\n          maxNumResults,\n          maxHops: maxHops - 1\n        }, [...currentPairs, pair], amountOut, bestTrades);\n      }\n    }\n    return bestTrades;\n  }\n  worstExecutionPrice(slippageTolerance) {\n    return new Price3(this.inputAmount.currency, this.outputAmount.currency, this.maximumAmountIn(slippageTolerance).quotient, this.minimumAmountOut(slippageTolerance).quotient);\n  }\n  static bestTradeExactOut(pairs, currencyIn, currencyAmountOut, { maxNumResults = 3, maxHops = 3 } = {}, currentPairs = [], nextAmountOut = currencyAmountOut, bestTrades = []) {\n    invariant4(pairs.length > 0, \"PAIRS\");\n    invariant4(maxHops > 0, \"MAX_HOPS\");\n    invariant4(currencyAmountOut === nextAmountOut || currentPairs.length > 0, \"INVALID_RECURSION\");\n    const amountOut = nextAmountOut.wrapped;\n    const tokenIn = currencyIn.wrapped;\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i];\n      if (!pair.token0.equals(amountOut.currency) && !pair.token1.equals(amountOut.currency))\n        continue;\n      if (pair.reserve0.equalTo(ZERO2) || pair.reserve1.equalTo(ZERO2))\n        continue;\n      let amountIn;\n      try {\n        ;\n        [amountIn] = pair.getInputAmount(amountOut);\n      } catch (error) {\n        if (error.isInsufficientReservesError) {\n          continue;\n        }\n        throw error;\n      }\n      if (amountIn.currency.equals(tokenIn)) {\n        sortedInsert(bestTrades, new Trade(new Route([pair, ...currentPairs], currencyIn, currencyAmountOut.currency), currencyAmountOut, TradeType.EXACT_OUTPUT), maxNumResults, tradeComparator);\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length));\n        Trade.bestTradeExactOut(pairsExcludingThisPair, currencyIn, currencyAmountOut, {\n          maxNumResults,\n          maxHops: maxHops - 1\n        }, [pair, ...currentPairs], amountIn, bestTrades);\n      }\n    }\n    return bestTrades;\n  }\n};\n\n// src/entities/native.ts\nimport invariant5 from \"tiny-invariant\";\nimport { NativeCurrency } from \"@pancakeswap/swap-sdk-core\";\nvar _Native = class extends NativeCurrency {\n  constructor({\n    chainId,\n    decimals,\n    name,\n    symbol\n  }) {\n    super(chainId, decimals, symbol, name);\n  }\n  get wrapped() {\n    const wnative = WNATIVE[this.chainId];\n    invariant5(!!wnative, \"WRAPPED\");\n    return wnative;\n  }\n  static onChain(chainId) {\n    if (chainId in this.cache) {\n      return this.cache[chainId];\n    }\n    invariant5(!!NATIVE[chainId], \"NATIVE_CURRENCY\");\n    const { decimals, name, symbol } = NATIVE[chainId];\n    return this.cache[chainId] = new _Native({ chainId, decimals, symbol, name });\n  }\n  equals(other) {\n    return other.isNative && other.chainId === this.chainId;\n  }\n};\nvar Native = _Native;\nNative.cache = {};\n\n// src/router.ts\nimport { TradeType as TradeType2 } from \"@pancakeswap/swap-sdk-core\";\nimport invariant6 from \"tiny-invariant\";\nfunction toHex(currencyAmount) {\n  return `0x${currencyAmount.quotient.toString(16)}`;\n}\nvar ZERO_HEX = \"0x0\";\nvar Router = class {\n  constructor() {\n  }\n  static swapCallParameters(trade, options) {\n    const etherIn = trade.inputAmount.currency.isNative;\n    const etherOut = trade.outputAmount.currency.isNative;\n    invariant6(!(etherIn && etherOut), \"ETHER_IN_OUT\");\n    invariant6(!(\"ttl\" in options) || options.ttl > 0, \"TTL\");\n    const to = validateAndParseAddress(options.recipient);\n    const amountIn = toHex(trade.maximumAmountIn(options.allowedSlippage));\n    const amountOut = toHex(trade.minimumAmountOut(options.allowedSlippage));\n    const path = trade.route.path.map((token) => token.address);\n    const deadline = \"ttl\" in options ? `0x${(Math.floor(new Date().getTime() / 1e3) + options.ttl).toString(16)}` : `0x${options.deadline.toString(16)}`;\n    const useFeeOnTransfer = Boolean(options.feeOnTransfer);\n    let methodName;\n    let args;\n    let value;\n    switch (trade.tradeType) {\n      case TradeType2.EXACT_INPUT:\n        if (etherIn) {\n          methodName = useFeeOnTransfer ? \"swapExactETHForTokensSupportingFeeOnTransferTokens\" : \"swapExactETHForTokens\";\n          args = [amountOut, path, to, deadline];\n          value = amountIn;\n        } else if (etherOut) {\n          methodName = useFeeOnTransfer ? \"swapExactTokensForETHSupportingFeeOnTransferTokens\" : \"swapExactTokensForETH\";\n          args = [amountIn, amountOut, path, to, deadline];\n          value = ZERO_HEX;\n        } else {\n          methodName = useFeeOnTransfer ? \"swapExactTokensForTokensSupportingFeeOnTransferTokens\" : \"swapExactTokensForTokens\";\n          args = [amountIn, amountOut, path, to, deadline];\n          value = ZERO_HEX;\n        }\n        break;\n      case TradeType2.EXACT_OUTPUT:\n        invariant6(!useFeeOnTransfer, \"EXACT_OUT_FOT\");\n        if (etherIn) {\n          methodName = \"swapETHForExactTokens\";\n          args = [amountOut, path, to, deadline];\n          value = amountIn;\n        } else if (etherOut) {\n          methodName = \"swapTokensForExactETH\";\n          args = [amountOut, amountIn, path, to, deadline];\n          value = ZERO_HEX;\n        } else {\n          methodName = \"swapTokensForExactTokens\";\n          args = [amountOut, amountIn, path, to, deadline];\n          value = ZERO_HEX;\n        }\n        break;\n    }\n    return {\n      methodName,\n      args,\n      value\n    };\n  }\n};\n\n// src/index.ts\nexport * from \"@pancakeswap/swap-sdk-core\";\nexport {\n  ChainId,\n  ERC20Token,\n  FACTORY_ADDRESS,\n  FACTORY_ADDRESS_MAP,\n  INIT_CODE_HASH,\n  INIT_CODE_HASH_MAP,\n  JSBI2 as JSBI,\n  NATIVE,\n  Native,\n  ONE_HUNDRED_PERCENT,\n  Pair,\n  Route,\n  Router,\n  Trade,\n  WBNB,\n  WETH9,\n  WNATIVE,\n  ZERO_PERCENT,\n  computePairAddress,\n  inputOutputComparator,\n  isTradeBetter,\n  tradeComparator\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}