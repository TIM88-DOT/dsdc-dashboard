{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.isAddress = exports.getAddress = void 0;\nvar bytes_1 = require(\"@ethersproject/bytes\");\nvar bignumber_1 = require(\"@ethersproject/bignumber\");\nvar keccak256_1 = require(\"@ethersproject/keccak256\");\nvar rlp_1 = require(\"@ethersproject/rlp\");\nvar logger_1 = require(\"@ethersproject/logger\");\nvar _version_1 = require(\"./_version\");\nvar logger = new logger_1.Logger(_version_1.version);\nfunction getChecksumAddress(address) {\n  if (!(0, bytes_1.isHexString)(address, 20)) {\n    logger.throwArgumentError(\"invalid address\", \"address\", address);\n  }\n  address = address.toLowerCase();\n  var chars = address.substring(2).split(\"\");\n  var expanded = new Uint8Array(40);\n  for (var i = 0; i < 40; i++) {\n    expanded[i] = chars[i].charCodeAt(0);\n  }\n  var hashed = (0, bytes_1.arrayify)((0, keccak256_1.keccak256)(expanded));\n  for (var i = 0; i < 40; i += 2) {\n    if (hashed[i >> 1] >> 4 >= 8) {\n      chars[i] = chars[i].toUpperCase();\n    }\n    if ((hashed[i >> 1] & 0x0f) >= 8) {\n      chars[i + 1] = chars[i + 1].toUpperCase();\n    }\n  }\n  return \"0x\" + chars.join(\"\");\n}\n// Shims for environments that are missing some required constants and functions\nvar MAX_SAFE_INTEGER = 0x1fffffffffffff;\nfunction log10(x) {\n  if (Math.log10) {\n    return Math.log10(x);\n  }\n  return Math.log(x) / Math.LN10;\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nvar ibanLookup = {};\nfor (var i = 0; i < 10; i++) {\n  ibanLookup[String(i)] = String(i);\n}\nfor (var i = 0; i < 26; i++) {\n  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nvar safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\nfunction ibanChecksum(address) {\n  address = address.toUpperCase();\n  address = address.substring(4) + address.substring(0, 2) + \"00\";\n  var expanded = address.split(\"\").map(function (c) {\n    return ibanLookup[c];\n  }).join(\"\");\n  // Javascript can handle integers safely up to 15 (decimal) digits\n  while (expanded.length >= safeDigits) {\n    var block = expanded.substring(0, safeDigits);\n    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n  }\n  var checksum = String(98 - parseInt(expanded, 10) % 97);\n  while (checksum.length < 2) {\n    checksum = \"0\" + checksum;\n  }\n  return checksum;\n}\n;\nfunction getAddress(address) {\n  var result = null;\n  if (typeof address !== \"string\") {\n    logger.throwArgumentError(\"invalid address\", \"address\", address);\n  }\n  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n    // Missing the 0x prefix\n    if (address.substring(0, 2) !== \"0x\") {\n      address = \"0x\" + address;\n    }\n    result = getChecksumAddress(address);\n    // It is a checksummed address with a bad checksum\n    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n      logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n    }\n    // Maybe ICAP? (we only support direct mode)\n  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n    // It is an ICAP address with a bad checksum\n    if (address.substring(2, 4) !== ibanChecksum(address)) {\n      logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n    }\n    result = (0, bignumber_1._base36To16)(address.substring(4));\n    while (result.length < 40) {\n      result = \"0\" + result;\n    }\n    result = getChecksumAddress(\"0x\" + result);\n  } else {\n    logger.throwArgumentError(\"invalid address\", \"address\", address);\n  }\n  return result;\n}\nexports.getAddress = getAddress;\nfunction isAddress(address) {\n  try {\n    getAddress(address);\n    return true;\n  } catch (error) {}\n  return false;\n}\nexports.isAddress = isAddress;\nfunction getIcapAddress(address) {\n  var base36 = (0, bignumber_1._base16To36)(getAddress(address).substring(2)).toUpperCase();\n  while (base36.length < 30) {\n    base36 = \"0\" + base36;\n  }\n  return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\nexports.getIcapAddress = getIcapAddress;\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nfunction getContractAddress(transaction) {\n  var from = null;\n  try {\n    from = getAddress(transaction.from);\n  } catch (error) {\n    logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n  }\n  var nonce = (0, bytes_1.stripZeros)((0, bytes_1.arrayify)(bignumber_1.BigNumber.from(transaction.nonce).toHexString()));\n  return getAddress((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, rlp_1.encode)([from, nonce])), 12));\n}\nexports.getContractAddress = getContractAddress;\nfunction getCreate2Address(from, salt, initCodeHash) {\n  if ((0, bytes_1.hexDataLength)(salt) !== 32) {\n    logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n  }\n  if ((0, bytes_1.hexDataLength)(initCodeHash) !== 32) {\n    logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n  }\n  return getAddress((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.concat)([\"0xff\", getAddress(from), salt, initCodeHash])), 12));\n}\nexports.getCreate2Address = getCreate2Address;","map":{"version":3,"sources":["../src.ts/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.isAddress = exports.getAddress = void 0;\nvar bytes_1 = require(\"@ethersproject/bytes\");\nvar bignumber_1 = require(\"@ethersproject/bignumber\");\nvar keccak256_1 = require(\"@ethersproject/keccak256\");\nvar rlp_1 = require(\"@ethersproject/rlp\");\nvar logger_1 = require(\"@ethersproject/logger\");\nvar _version_1 = require(\"./_version\");\nvar logger = new logger_1.Logger(_version_1.version);\nfunction getChecksumAddress(address) {\n    if (!(0, bytes_1.isHexString)(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    address = address.toLowerCase();\n    var chars = address.substring(2).split(\"\");\n    var expanded = new Uint8Array(40);\n    for (var i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    var hashed = (0, bytes_1.arrayify)((0, keccak256_1.keccak256)(expanded));\n    for (var i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// Shims for environments that are missing some required constants and functions\nvar MAX_SAFE_INTEGER = 0x1fffffffffffff;\nfunction log10(x) {\n    if (Math.log10) {\n        return Math.log10(x);\n    }\n    return Math.log(x) / Math.LN10;\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nvar ibanLookup = {};\nfor (var i = 0; i < 10; i++) {\n    ibanLookup[String(i)] = String(i);\n}\nfor (var i = 0; i < 26; i++) {\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nvar safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    var expanded = address.split(\"\").map(function (c) { return ibanLookup[c]; }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits) {\n        var block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    var checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) {\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nfunction getAddress(address) {\n    var result = null;\n    if (typeof (address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") {\n            address = \"0x\" + address;\n        }\n        result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n        // Maybe ICAP? (we only support direct mode)\n    }\n    else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n        result = (0, bignumber_1._base36To16)(address.substring(4));\n        while (result.length < 40) {\n            result = \"0\" + result;\n        }\n        result = getChecksumAddress(\"0x\" + result);\n    }\n    else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    return result;\n}\nexports.getAddress = getAddress;\nfunction isAddress(address) {\n    try {\n        getAddress(address);\n        return true;\n    }\n    catch (error) { }\n    return false;\n}\nexports.isAddress = isAddress;\nfunction getIcapAddress(address) {\n    var base36 = (0, bignumber_1._base16To36)(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) {\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\nexports.getIcapAddress = getIcapAddress;\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nfunction getContractAddress(transaction) {\n    var from = null;\n    try {\n        from = getAddress(transaction.from);\n    }\n    catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n    var nonce = (0, bytes_1.stripZeros)((0, bytes_1.arrayify)(bignumber_1.BigNumber.from(transaction.nonce).toHexString()));\n    return getAddress((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, rlp_1.encode)([from, nonce])), 12));\n}\nexports.getContractAddress = getContractAddress;\nfunction getCreate2Address(from, salt, initCodeHash) {\n    if ((0, bytes_1.hexDataLength)(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if ((0, bytes_1.hexDataLength)(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.concat)([\"0xff\", getAddress(from), salt, initCodeHash])), 12));\n}\nexports.getCreate2Address = getCreate2Address;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}